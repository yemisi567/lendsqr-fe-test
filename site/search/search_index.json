{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Lendsqr User Management Dashboard Documentation","text":"<p>Welcome to the Lendsqr User Management Dashboard Docs. This documentation covers installation, features, API structure, and deployment.</p>"},{"location":"#overview","title":"Overview","text":"<p>The User Management Dashboard is a React (TypeScript) web application for managing users with pagination, filtering, authentication, and more.</p> <p>Below is a brief description of key Features included in this repository:</p> <ul> <li>Authentication - Authentication flow for secure login functionality.</li> <li>User Management - View, Filter, and Paginate users list.</li> <li>Custom Hooks - Efficient filtering and pagination.</li> <li>Context API &amp; Reducers - Centralized state management.</li> <li>Error Boundary Handling - Fallback UI in case of errors.</li> <li>Unit &amp; Integration Testing - Comprehensive test for components.</li> </ul> <p>For a quick start, check out my Installation Guide.</p>"},{"location":"authentication/","title":"Authentication","text":""},{"location":"authentication/#authentication-details","title":"Authentication Details","text":"<p>Authentication Approach</p> <ul> <li> <p>React Context API &amp; useReducer: Manages authentication state.</p> </li> <li> <p>Login Validation: Email and password validation using helper functions.</p> </li> <li> <p>Session Persistence: User authentication is stored in cookies.</p> </li> </ul> <p>Implementation</p> <ul> <li> <p>Users must log in before accessing the dashboard.</p> </li> <li> <p>Incorrect credentials result in error messages.</p> </li> <li> <p>Successful authentication redirects to /dashboard/users.</p> </li> </ul>"},{"location":"contact/","title":"Contact","text":""},{"location":"contact/#contact-information","title":"Contact Information","text":"<p>For any inquiries or support, reach out to:</p> <ul> <li> <p>Email: alegbeyemi@gmail.com</p> </li> <li> <p>GitHub Repo: https://github.com/yemisi567/lendsqr-fe-test.git</p> </li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contribution-guidelines","title":"Contribution Guidelines","text":"<p>How to Contribute</p> <ul> <li> <p>Fork the repository.</p> </li> <li> <p>Create a feature branch: git checkout -b feature-branch.</p> </li> <li> <p>Commit changes: git commit -m \"Description of changes\".</p> </li> <li> <p>Push to branch: git push origin feature-branch.</p> </li> <li> <p>Submit a pull request.</p> </li> </ul> <p>Code Standards</p> <ul> <li> <p>Follow ESLint rules.</p> </li> <li> <p>Use TypeScript for type safety.</p> </li> <li> <p>Write unit tests with Vitest.</p> </li> </ul>"},{"location":"deployment/","title":"Deployment","text":""},{"location":"deployment/#deployment-guide","title":"Deployment Guide","text":"<p>Netlify Deployment Steps</p> <ul> <li> <p>I Pushed the code to GitHub.</p> </li> <li> <p>Sign in to Netlify and create a new site.</p> </li> <li> <p>Connect the GitHub repository.</p> </li> <li> <p>Set up environment Variables.</p> </li> <li> <p>Deploy and obtain the live link.</p> </li> </ul> <p>Environment Variables</p> <ul> <li>VITE_MOCKY_URL: API URL.</li> <li>VITE_AUTH_TOKEN: Authentication token.</li> <li>VITE_MOCKY_ID=Mock Id</li> </ul>"},{"location":"error_boundary/","title":"Error Handling","text":""},{"location":"error_boundary/#error-boundary-handling","title":"Error Boundary Handling","text":"<p>Why Error Boundaries?</p> <p>Error boundaries ensure a graceful fallback UI when unexpected errors occur in my application.</p> <p>Implementation</p> <p>I created an ErrorBoundary component using React componentDidCatch() to catch errors and display a fallback UI instead of breaking the entire app.</p> <pre><code>import React, { Component, ReactNode } from \"react\";\nimport styles from \"./ErrorBoundary.module.scss\";\nimport Button from \"../../ui/Button/Button\";\n\ninterface Props {\n  children: ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n  error?: Error;\n}\n\nclass ErrorBoundary extends Component&lt;Props, State&gt; {\n  constructor(props: Props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error(\"Error caught by ErrorBoundary:\", error, errorInfo);\n  }\n\n  handleRefresh = () =&gt; {\n    window.location.reload();\n  };\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        &lt;div className={styles.errorBoundary}&gt;\n          &lt;h1&gt;Something went wrong \ud83d\ude22&lt;/h1&gt;\n          &lt;p&gt;We encountered an error. Please try refreshing the page.&lt;/p&gt;\n          &lt;Button onClick={this.handleRefresh}&gt;Reload Page&lt;/Button&gt;\n        &lt;/div&gt;\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation-guide","title":"Installation Guide","text":"<p>Prerequisites</p> <ul> <li> <p>Node.js (v16+)</p> </li> <li> <p>npm or yarn</p> </li> </ul> <p>Setup Steps</p> <ul> <li>Clone the repository:</li> </ul> <pre><code>git clone https://github.com/yemisi567/lendsqr-fe-test.git\ncd lendsqr-dahsboard\n</code></pre> <ul> <li>Install dependencies:</li> </ul> <pre><code>npm install \n</code></pre> <p>Start development server:</p> <pre><code>npm run dev\n</code></pre>"},{"location":"pagination_filtering/","title":"Pagination & Filtering","text":""},{"location":"pagination_filtering/#pagination-filtering","title":"Pagination &amp; Filtering","text":"<p>Filtering Users</p> <p>Uses a custom useFilter hook to filter users by:</p> <ul> <li> <p>Organization, Username, Email, Phone, Status, Date Joined.</p> </li> <li> <p>Search parameters are managed via React Router\u2019s useSearchParams().</p> </li> </ul> <p>Pagination System</p> <ul> <li> <p>Custom usePagination hook.</p> </li> <li> <p>Handles next/previous page navigation.</p> </li> <li> <p>Dynamic page size selection.</p> </li> </ul>"},{"location":"project_decisions/","title":"Project Approach &amp; Decisions","text":"<p>This page documents key decisions taken during the development of the Lendsqr Dashboard, the reasoning behind them.</p>"},{"location":"project_decisions/#1-why-react-with-typescript","title":"1. Why React with TypeScript?","text":"<ul> <li>Type Safety: Prevents runtime errors with strong typing.</li> <li>Scalability: TypeScript is better suited for large applications with multiple developers.</li> <li>Better Developer Experience: Provides auto-completion &amp; IntelliSense.</li> <li>Code Maintainability: Helps detect bugs early and enforce coding standards.</li> </ul> <p>Impact on the Final Outcome By choosing React with TypeScript, I ensured that the user management system was robust, well-typed, and easier to debug and scale.</p>"},{"location":"project_decisions/#2-state-management-why-context-api-over-redux","title":"2. State Management: Why Context API over Redux?","text":"<ul> <li>Simplicity: Redux introduces extra boilerplate; Context API is built-in.</li> <li>Performance: Using React Context + useReducer improves state management while keeping the code lightweight.</li> <li>Easier Maintenance: Fewer dependencies mean easier upgrades.</li> </ul> <p>Impact on the Final Outcome The combination of React Context and useReducer provided an efficient, lightweight state management system that scaled well without introducing unnecessary complexity.</p>"},{"location":"project_decisions/#3-error-handling-strategy","title":"3. Error Handling Strategy","text":"<p>To ensure application stability, I implemented a Global Error Boundary that catches unexpected errors and prevents app crashes.</p>"},{"location":"project_decisions/#code-implementation","title":"Code Implementation","text":"<pre><code>import React, { Component, ReactNode } from \"react\";\nimport styles from \"./ErrorBoundary.module.scss\";\nimport Button from \"../../ui/Button/Button\";\n\ninterface Props {\n  children: ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n  error?: Error;\n}\n\nclass ErrorBoundary extends Component&lt;Props, State&gt; {\n  constructor(props: Props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error(\"Error caught by ErrorBoundary:\", error, errorInfo);\n  }\n\n  handleRefresh = () =&gt; {\n    window.location.reload();\n  };\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        &lt;div className={styles.errorBoundary}&gt;\n          &lt;h1&gt;Something went wrong \ud83d\ude22&lt;/h1&gt;\n          &lt;p&gt;We encountered an error. Please try refreshing the page.&lt;/p&gt;\n          &lt;Button onClick={this.handleRefresh}&gt;Reload Page&lt;/Button&gt;\n        &lt;/div&gt;\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n</code></pre> <p>Impact on the Final Outcome The ErrorBoundary component improved application resilience by gracefully handling crashes. Users are shown a fallback page instead of the entire application breaking.</p>"},{"location":"project_decisions/#4-pagination-filtering-strategy-why-client-side-pagination","title":"4. Pagination &amp; Filtering Strategy: Why Client-side Pagination?","text":"<p>Instead of server-side pagination, I opted for client-side pagination and implemented a custom <code>usePagination</code> hook for optimized state updates.</p> <p>Reasons for This Decision</p> <ul> <li> <p>Faster user experience for small datasets.</p> </li> <li> <p>No additional API requests are needed.</p> </li> <li> <p>Better for static or rarely updated data.</p> </li> </ul> <pre><code>const { handleOnNext, handleOnPrevious, page, start, end } = usePagination(\n  users.length\n);\n</code></pre> <p>Filtering Approach</p> <p>A custom <code>useFilter</code> hook was implemented to handle filtering logic dynamically.</p> <p>Why This Approach?</p> <ul> <li> <p>Allows real-time filtering without needing API requests.</p> </li> <li> <p>Uses memoization <code>useMemo</code> for performance optimizations.</p> </li> </ul> <p>Impact on the Final Outcome</p> <p>This decision resulted in a faster, more interactive user experience, especially since my dataset is not constantly changing. However, for larger datasets, a server-side pagination strategy might be required</p>"},{"location":"project_decisions/#5-testing-approach-why-vitest","title":"5. Testing Approach: Why Vitest?","text":"<ul> <li> <p>Faster than Jest \u2013 Runs tests more efficiently.</p> </li> <li> <p>Compatible with React Testing Library.</p> </li> <li> <p>Supports TypeScript out-of-the-box.</p> </li> <li> <p>Mocks and spies are simpler to use.</p> </li> </ul> <p>Impact on the Final Outcome</p> <ul> <li> <p>All core features <code>authentication, user management, filtering, pagination</code> work as expected.</p> </li> <li> <p>Edge cases were covered (e.g., missing user data, invalid filters, etc.).</p> </li> <li> <p>Code changes are validated before deployment.</p> </li> </ul> <p>Example Test Implementation</p> <pre><code>import { render, screen } from \"@testing-library/react\";\nimport { describe, it, expect, vi } from \"vitest\";\nimport UsersList from \"../UsersList\";\n\ndescribe(\"UsersList Component\", () =&gt; {\n  it(\"renders user table\", () =&gt; {\n    render(&lt;UsersList /&gt;);\n    expect(screen.getByText(\"Users\")).toBeInTheDocument();\n  });\n});\n</code></pre>"},{"location":"project_decisions/#6-deployment-strategy-why-netlify","title":"6. Deployment Strategy: Why Netlify?","text":"<p>I deployed the project using Netlify because of:</p> <ul> <li> <p>Ease of deployment \u2013 Direct GitHub integration for automatic updates.</p> </li> <li> <p>Free tier availability \u2013 Supports frontend hosting with minimal configuration.</p> </li> <li> <p>Built-in CI/CD \u2013 Every push triggers an automatic build &amp; deployment.</p> </li> </ul> <p>Impact on the Final Outcome</p> <p>Using Netlify ensured rapid deployments, version control, and a streamlined workflow.</p> <p>Deployment Process</p> <pre><code>git push origin main\n</code></pre>"},{"location":"structure/","title":"Project Structure","text":""},{"location":"structure/#project-directory","title":"Project Directory","text":"<p>Below is the complete directory structure of the Lendsqr User Management Dashboard:</p> <pre><code>src/\n \u251c\u2500\u2500 components/                     # Reusable components\n \u251c\u2500\u2500 constants/                      # Reusable data\n \u251c\u2500\u2500 context/                        # Auth &amp; Users Context\n \u251c\u2500\u2500 hooks/                          # Custom hooks (useFilter, usePagination)\n \u251c\u2500\u2500 pages/                          # Application pages\n \u251c\u2500\u2500 types/                          # TypeScript interfaces\n \u251c\u2500\u2500 components/test.tsx             # Unit &amp; integration tests\n \u251c\u2500\u2500 Icons/                          # Icons used across app\n\n</code></pre>"},{"location":"testing/","title":"Testing","text":""},{"location":"testing/#testing-strategy","title":"Testing Strategy","text":"<p>Testing Tools</p> <ul> <li> <p>Vitest: Unit Testing</p> </li> <li> <p>React Testing Library: UI Testing.</p> </li> </ul> <p>Test Cases</p> <ul> <li> <p>Authentication Tests: Ensures valid user login.</p> </li> <li> <p>User Management Tests: Tests pagination, filtering, Buttons and all other components</p> </li> <li> <p>Error Boundary Tests: Ensures fallback UI renders correctly.</p> </li> </ul> <p>Run tests with:</p> <pre><code>npm test\n</code></pre>"},{"location":"user_management/","title":"User Management","text":""},{"location":"user_management/#user-management","title":"User Management","text":"<p>User Actions</p> <ul> <li> <p>View Users: Lists users fetched from API.</p> </li> <li> <p>Search &amp; Filter: Uses useFilter custom hook.</p> </li> <li> <p>Pagination: Uses usePagination custom hook.</p> </li> </ul> <p>State Management</p> <ul> <li> <p>UsersContext manages user-related state.</p> </li> <li> <p>Reducer pattern improves performance by reducing unnecessary re-renders.</p> </li> </ul>"}]}